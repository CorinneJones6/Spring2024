import javax.crypto.spec.DHParameterSpec;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.math.BigInteger;
import java.security.*;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;


public class Shared {
    private static final BigInteger g = new BigInteger("2"); // base generator
    private static final BigInteger N = new BigInteger("1"); // prime modulus, replace "..." with a large prime value

    static Certificate CACertificate;

    static {
        try {
            CACertificate = Shared.getHostCertificate("CA");
        } catch (CertificateException e) {
            throw new RuntimeException(e);
        }
    }

    public static String bytesToHex(byte[] bytes) {
        StringBuilder hexString = new StringBuilder();
        for (byte b : bytes) {
            String hex = Integer.toHexString(0xff & b);
            if (hex.length() == 1) hexString.append('0');
            hexString.append(hex);
        }
        return hexString.toString();
    }
    public static Certificate getHostCertificate(String caller) throws CertificateException {
        String filepath;
        if(caller.equals("server")){
            filepath = "../TLSDirectory/CASignedServerCertificate.pem";
        }
        else if(caller.equals("client")) {
            filepath = "../TLSDirectory/CASignedClientCertificate.pem";
        }
        else if(caller.equals("CA")){
            filepath = "../TLSDirectory/CACertificate.pem";
        }
        else {
            throw new IllegalArgumentException("invalid name provided");
        }
        try (FileInputStream fileInput = new FileInputStream(filepath)) {
            CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
            return certificateFactory.generateCertificate(fileInput);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public static BigInteger[] generateDHKeyPair() throws InvalidAlgorithmParameterException, NoSuchAlgorithmException {
        BigInteger[] returnArray = new BigInteger[2];

        BigInteger privateKey = generateDHPrivateKey(N.bitLength());

        BigInteger publicKey = generateDHPublicKey(privateKey);

        returnArray[0] = privateKey;
        returnArray[1] = publicKey;

        return returnArray;
    }

    private static BigInteger generateDHPrivateKey(int bitLength) {
        SecureRandom random = new SecureRandom();
        return new BigInteger(bitLength - 1, random); // Ensure the private key is suitably large
    }
    private static BigInteger generateDHPublicKey(BigInteger privateKey){
        return g.modPow(privateKey, N);
    }

    //TODO: Figure out the signed DH key
    public static BigInteger generateSignedDHKey(String caller, BigInteger DHPublicKey, PublicKey RSAPublicKey){
        String filepath;
        if(caller.equals("server")){
            filepath = "../TLSDirectory/serverPrivateKey.der";
        }
        else if(caller.equals("client")){
            filepath = "../TLSDirectory/clientPrivateKey.der";
        }
        else {
            throw new IllegalArgumentException("invalid name provided");
        }

        try {
            //Read in privateKeyDer file, extract the private keys bytes and encode it
            FileInputStream privateKeyDer_file_input = new FileInputStream(filepath);
            byte[] privateKeyBytes = privateKeyDer_file_input.readAllBytes();
            PKCS8EncodedKeySpec encodedPrivateKeyBytes = new PKCS8EncodedKeySpec(privateKeyBytes);

            //Generate private-RSA-key
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");
            PrivateKey privateRSAKey =  keyFactory.generatePrivate(encodedPrivateKeyBytes);

            //Sign with private key
            Signature signature = Signature.getInstance("SHA256withRSA");
            signature.initSign(privateRSAKey);//private key is used to generate the signature, ensuring that only the holder of the private key can sign the data
            signature.update(DHPublicKey.toByteArray());// adds the data to be signed by the signature object
            byte[] signedPublicKey = signature.sign(); //computes the signature of the provided data (the DH public key) using the private RSA key

            //Verification and update
            signature.initVerify(RSAPublicKey); //re-initialize Signature. Public key is used to verify that the signature was generated by the matching private key
            signature.update(DHPublicKey.toByteArray()); //original data (DH public key) to compute its own signature for comparison

            return new BigInteger(signedPublicKey);

        }catch (IOException | NoSuchAlgorithmException | InvalidKeySpecException | InvalidKeyException |
                SignatureException e){
            throw new RuntimeException(e);
        }
    }

    static boolean validateCertificate(Certificate certificate) {
        try {
            PublicKey CApublicKey = Shared.CACertificate.getPublicKey();
            certificate.verify(CApublicKey);
            return true; // Verification successful
        } catch (CertificateException | NoSuchAlgorithmException | SignatureException | InvalidKeyException | NoSuchProviderException e) {
            // Any exception caught here indicates the certificate could not be verified.
            return false; // Verification failed
        }
    }

    static BigInteger generateMasterKey(BigInteger DHPublicKey, BigInteger DHPrivateKey){
        return DHPublicKey.modPow(DHPrivateKey, N);
    }

    static void generateSessionKeys(BigInteger key){
        System.out.println("YOU ARE THE WINNER");
    }

}
