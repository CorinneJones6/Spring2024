import javax.crypto.*;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.io.*;
import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.*;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.Arrays;
/**
 * This class provides shared utilities for secure communication between a client and server.
 * It includes methods for certificate management, key generation and agreement,
 * data encryption and decryption, message authentication, and session key derivation
 * using Diffie-Hellman (DH) key exchange, RSA encryption, and HMAC for message integrity.
 *
 * Created by Corinne Jones in 3/2024
 *
 */
public class Shared {
    private static final BigInteger g = new BigInteger("2"); // base generator
    private static final BigInteger N = new BigInteger("1"); // prime modulus
    static byte[] serverEncrypt;
    static byte[] clientEncrypt;
    static byte[] serverMAC;
    static byte[] clientMAC;
    static byte[] serverIV;
    static byte[] clientIV;
    static Certificate CACertificate = Shared.getHostCertificate("CA");
    /**
     * Converts a byte array to a hexadecimal string.
     *
     * @param bytes the byte array to convert.
     * @return a string representing the hexadecimal value of the byte array.
     */
    public static String bytesToHex(byte[] bytes) {
        StringBuilder hexString = new StringBuilder();
        for (byte b : bytes) {
            String hex = Integer.toHexString(0xff & b);
            if (hex.length() == 1) hexString.append('0');
            hexString.append(hex);
        }
        return hexString.toString();
    }
    /**
     * Retrieves a certificate from a specified file path based on the caller's identity.
     *
     * @param caller the identity of the caller (server, client, or CA).
     * @return the certificate from the specified file path.
     */
    public static Certificate getHostCertificate(String caller) {
        String filepath = switch (caller) {
            case "server" -> "../TLSDirectory/CASignedServerCertificate.pem";
            case "client" -> "../TLSDirectory/CASignedClientCertificate.pem";
            case "CA" -> "../TLSDirectory/CACertificate.pem";
            default -> throw new IllegalArgumentException("invalid name provided");
        };
        try (FileInputStream fileInput = new FileInputStream(filepath)) {
            CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
            return certificateFactory.generateCertificate(fileInput);
        } catch (IOException e) {
            throw new RuntimeException("Certificate file not found: " + e.getMessage(), e);
        } catch (CertificateException e) {
            throw new RuntimeException("Error processing certificate: " + e.getMessage(), e);
        }
    }
    /**
     * Generates a Diffie-Hellman key pair.
     *
     * @return an array containing the private key and public key in that order.
     */
    public static BigInteger[] generateDHKeyPair() {
        BigInteger[] returnArray = new BigInteger[2];

        BigInteger privateKey = generateDHPrivateKey(N.bitLength());

        BigInteger publicKey = generateDHPublicKey(privateKey);

        returnArray[0] = privateKey;
        returnArray[1] = publicKey;

        return returnArray;
    }
    /**
     * Generates a private key for Diffie-Hellman key exchange.
     * The method creates a private key of the specified bit length minus one to ensure it's suitably large.
     *
     * @param bitLength the length of the key in bits.
     * @return a BigInteger representing the private key.
     */
    private static BigInteger generateDHPrivateKey(int bitLength) {
        SecureRandom random = new SecureRandom();
        return new BigInteger(bitLength - 1, random);
    }
    /**
     * Generates a public key for Diffie-Hellman key exchange.
     * The public key is generated by raising the base generator 'g' to the power of the private key,
     * modulo the prime modulus 'N'.
     *
     * @param privateKey the private key for Diffie-Hellman key exchange.
     * @return a BigInteger representing the public key.
     */
    private static BigInteger generateDHPublicKey(BigInteger privateKey){
        return g.modPow(privateKey, N);
    }
    /**
     * Generates an RSA private key from a specified file path.
     * This method reads the private key bytes from the file, then constructs and returns the RSA private key.
     *
     * @param filepath the path to the file containing the RSA private key in PKCS#8 format.
     * @return a PrivateKey object representing the RSA private key.
     */
    private static PrivateKey generateRSAPrivateKey(String filepath) {
        try {
            byte[] keyBytes = Files.readAllBytes(Paths.get(filepath));
            PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);
            KeyFactory kf = KeyFactory.getInstance("RSA");
            return kf.generatePrivate(spec);
        } catch (IOException e) {
            throw new RuntimeException("Failed to read private key file: " + filepath, e);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("RSA algorithm not supported: " + e.getMessage(), e);
        } catch (InvalidKeySpecException e) {
            throw new RuntimeException("Invalid key specification: " + e.getMessage(), e);
        }
    }
    /**
     * Signs data using the RSA private key and SHA-256 with RSA signature algorithm.
     *
     * @param privateKey the RSA private key used for signing the data.
     * @param data the data to be signed.
     * @return a byte array containing the signature.
     */
    private static byte[] signData(PrivateKey privateKey, byte[] data) {
        try {
            Signature signature = Signature.getInstance("SHA256withRSA");
            signature.initSign(privateKey);
            signature.update(data);
            return signature.sign();
        } catch (Exception e) {
            throw new RuntimeException("Problem signing the data: " + e.getMessage(), e);
        }
    }
    /**
     * Generates a signed Diffie-Hellman public key.
     * This method is used to sign the DH public key using the caller's RSA private key.
     *
     * @param caller identifies the caller (server or client) to determine the private key to use.
     * @param DHPublicKey the Diffie-Hellman public key to be signed.
     * @return a byte array containing the signed Diffie-Hellman public key.
     */
    public static byte[] generateSignedDHKey(String caller, BigInteger DHPublicKey) {
        String filepath;
        if(caller.equals("server")){
            filepath = "../TLSDirectory/serverPrivateKey.der";
        }
        else if(caller.equals("client")){
            filepath = "../TLSDirectory/clientPrivateKey.der";
        }
        else {
            throw new IllegalArgumentException("invalid name provided");
        }
        PrivateKey RSAPrivateKey = generateRSAPrivateKey(filepath);

        byte[] DHPublicKey_Bytes = DHPublicKey.toByteArray();

        return signData(RSAPrivateKey, DHPublicKey_Bytes);
    }
    /**
     * Validates a certificate against the CA's public key.
     * This method verifies the certificate's validity by using the CA's public key.
     *
     * @param certificate the certificate to validate.
     * @return true if the certificate is valid, false otherwise.
     */
    static boolean validateCertificate(Certificate certificate) {
        try {
            PublicKey CApublicKey = Shared.CACertificate.getPublicKey();
            certificate.verify(CApublicKey);
            //Verification was successful
            return true;
        } catch (CertificateException | NoSuchAlgorithmException | SignatureException | InvalidKeyException | NoSuchProviderException e) {
            //Verification wasn't successful
            return false;
        }
    }
    /**
     * Generates a master key from a Diffie-Hellman public key and private key.
     * The master key is generated by performing a modPow operation with the public key and the private key.
     *
     * @param DHPublicKey the Diffie-Hellman public key.
     * @param DHPrivateKey the Diffie-Hellman private key.
     * @return a BigInteger representing the master key.
     */
    static BigInteger generateMasterKey(BigInteger DHPublicKey, BigInteger DHPrivateKey){
        return DHPublicKey.modPow(DHPrivateKey, N);
    }
    /**
     * Expands a key material into a new key of the desired length using the HKDF algorithm.
     *
     * @param input the input key material to expand.
     * @param tag a tag to differentiate the output key material.
     * @return a byte array containing the expanded key material.
     */
    public static byte[] hkdfExpand(byte[] input, String tag) {
        try {
            Mac mac = Mac.getInstance("HmacSHA256");
            mac.init(new SecretKeySpec(input, "HmacSHA256"));
            mac.update(tag.getBytes(StandardCharsets.UTF_8));
            mac.update((byte) 1);
            byte[] okm = mac.doFinal();
            byte[] result = new byte[16];
            System.arraycopy(okm, 0, result, 0, 16);
            return result;
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("HMAC SHA256 algorithm not found: " + e.getMessage(), e);
        } catch (InvalidKeyException e) {
            throw new RuntimeException("Invalid key used for HMAC SHA256: " + e.getMessage(), e);
        }
    }
    /**
     * Generates session keys for encryption, MAC, and IV from a master key and a client nonce.
     * This method uses the HKDF algorithm to derive session keys for both client and server.
     *
     * @param clientNonce the nonce used by the client, contributing to the session key's uniqueness.
     * @param masterKey the master key from which the session keys are derived.
     */
    static void generateSessionKeys(byte[] clientNonce, byte[] masterKey) {
        byte[] prk = hkdfExpand(masterKey, "masterKey" + new String(clientNonce, StandardCharsets.UTF_8));
        serverEncrypt = hkdfExpand(prk, "server encrypt");
        clientEncrypt = hkdfExpand(serverEncrypt, "client encrypt");
        serverMAC = hkdfExpand(clientEncrypt, "server MAC");
        clientMAC = hkdfExpand(serverMAC, "client MAC");
        serverIV = hkdfExpand(clientMAC, "server IV");
        clientIV = hkdfExpand(serverIV, "client IV");

        System.out.println("Session keys generated");
    }
    /**
     * Generates a message authentication code (MAC) for a given message using the specified key.
     *
     * @param message the message to be authenticated.
     * @param key the key used to generate the MAC.
     * @return a byte array containing the MAC of the message.
     */
    public static byte[] generateMacMessage(byte[] message, byte[] key) {
        try {
            Mac HMAC = Mac.getInstance("HmacSHA256");

            // Generate a new key from macKey and initializes the Mac instance with the new key
            SecretKeySpec secretKeySpec = new SecretKeySpec(key, "HmacSHA256");
            HMAC.init(secretKeySpec);

            HMAC.update(message);
            return HMAC.doFinal();
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("Failed to find the HmacSHA256 algorithm: " + e.getMessage(), e);
        } catch (InvalidKeyException e) {
            throw new RuntimeException("Invalid key used for HMAC SHA256: " + e.getMessage(), e);
        }
    }
    /**
     * Verifies the integrity and authenticity of a message history using a MAC.
     *
     * @param otherHostMacMsg the MAC of the message history received from the other host.
     * @param thisHostMsg the message history of this host.
     * @param macKey the key used to generate the MAC.
     * @return true if the MACs match (indicating integrity and authenticity), false otherwise.
     */
    public static boolean verifyMessageHistory(byte[] otherHostMacMsg, byte[] thisHostMsg, byte[] macKey) {
        byte[] thisHostMacMsg = Shared.generateMacMessage(thisHostMsg, macKey);
        return Arrays.equals(thisHostMacMsg, otherHostMacMsg);
    }
    /**
     * Generates a cipher for AES encryption or decryption in CBC mode with PKCS5 padding.
     *
     * @param key the key for AES encryption or decryption.
     * @param iv the initialization vector for CBC mode.
     * @param mode the operation mode (Cipher.ENCRYPT_MODE or Cipher.DECRYPT_MODE).
     */
    private static Cipher generateCipher(byte[] key, byte[] iv, int mode) {
        try {
            SecretKeySpec keySpec = new SecretKeySpec(key, "AES");
            IvParameterSpec ivSpec = new IvParameterSpec(iv);

            Cipher encryptCipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
            encryptCipher.init(mode, keySpec, ivSpec);

            return encryptCipher;
        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | InvalidAlgorithmParameterException e) {
            throw new RuntimeException("Error initializing cipher: " + e.getMessage(), e);
        }
    }
    /**
     * Encrypts a message with a given MAC key, encryption key, and IV, adding a MAC to ensure integrity.
     * The message is first converted to bytes, then a MAC is generated and appended to the message. Finally,
     * the concatenated bytes are encrypted using the specified encryption key and IV.
     *
     * @param message the message to encrypt.
     * @param MACkey the key used to generate the Message Authentication Code (MAC) for the message.
     * @param encryptKey the encryption key used for encrypting the message.
     * @param hostIV the initialization vector (IV) used for the encryption.
     * @return the encrypted message as a byte array.
     */
    public static byte[] encryptMessage(String message, byte[] MACkey, byte[] encryptKey, byte[] hostIV) {
        try {
            byte[] message_bytes = message.getBytes();
            ByteArrayOutputStream outStream = new ByteArrayOutputStream();
            outStream.write(message_bytes);

            byte[] hmac = Shared.generateMacMessage(message_bytes, MACkey);
            outStream.write(hmac);
            Cipher cipher = generateCipher(encryptKey, hostIV, Cipher.ENCRYPT_MODE);

            return cipher.doFinal(outStream.toByteArray());
        } catch (IOException | IllegalBlockSizeException | BadPaddingException | RuntimeException e) {
            throw new RuntimeException("Error encrypting message: " + e.getMessage(), e);
        }
    }
    /**
     * Decrypts a message using the specified decryption key and initialization vector (IV).
     * The method assumes that the last 32 bytes of the decrypted data are the MAC (Message Authentication Code),
     * which are not returned as part of the decrypted message. It uses AES/CBC/PKCS5Padding for decryption.
     *
     * @param encryptedData the data to decrypt.
     * @param decryptKey the key used for decryption.
     * @param hostIV the initialization vector used for decryption.
     * @return a String representation of the decrypted message, excluding the MAC.
     */
    public static String decryptMessage(byte[] encryptedData, byte[] decryptKey, byte[] hostIV) {
        try {
            Cipher cipher = generateCipher(decryptKey, hostIV, Cipher.DECRYPT_MODE);
            byte[] decryptedData = cipher.doFinal(encryptedData);
            byte[] messageBytes = Arrays.copyOf(decryptedData, decryptedData.length - 32);
            return new String(messageBytes, StandardCharsets.UTF_8);
        } catch (IllegalBlockSizeException | BadPaddingException e) {
            throw new RuntimeException("Error decrypting message: " + e.getMessage(), e);
        }
    }
    /**
     * Prints information about the encryption and decryption keys, MACs, and IVs used in the session.
     * This includes the keys and IVs for both the server and client sides. It is primarily used for debugging
     * and verification purposes to ensure that key material is correctly generated and exchanged.
     */
    public static void printKeyInformation() {
        System.out.println("Server Encrypt: " + bytesToHex(serverEncrypt));
        System.out.println("Client Encrypt: " + bytesToHex(clientEncrypt));
        System.out.println("Server MAC: " + bytesToHex(serverMAC));
        System.out.println("Client MAC: " + bytesToHex(clientMAC));
        System.out.println("Server IV: " + bytesToHex(serverIV));
        System.out.println("Client IV: " + bytesToHex(clientIV));
    }

            //////////////////////////////////////////////////////////////////////
            ////////////////      SHARED HANDSHAKE METHODS      /////////////////
            ////////////////////////////////////////////////////////////////////

    /**
     * Serializes and sends the server's certificate, Diffie-Hellman public key, and the signed DH public key to the client.
     * Each sent object is also recorded in the provided message history for later verification.
     *
     * @param os The ObjectOutputStream connected to the client, used to send the data.
     * @param dhPublicKey The server's Diffie-Hellman public key.
     * @param msgHistory A ByteArrayOutputStream to log the serialized objects sent, aiding in message integrity verification.
     */
    public static void sendCertificateAndKeys(ObjectOutputStream os, BigInteger dhPublicKey, ByteArrayOutputStream msgHistory) {
        try {
            Certificate serverCertificate = Shared.getHostCertificate("server");
            byte[] serverSignedDHKey_Bytes = Shared.generateSignedDHKey("server", dhPublicKey);

            os.writeObject(serverCertificate);
            msgHistory.write(serverCertificate.toString().getBytes());
            os.writeObject(dhPublicKey);
            msgHistory.write(dhPublicKey.toByteArray());
            os.writeObject(serverSignedDHKey_Bytes);
            msgHistory.write(serverSignedDHKey_Bytes);
            System.out.println("Certificate and Keys sent");
        } catch (IOException e) {
            throw new RuntimeException("Failed to send certificate and keys: " + e.getMessage(), e);
        }
    }
    /**
     * Receives and deserializes the client's certificate, Diffie-Hellman public key, and signed DH public key.
     * Each received object is also recorded in the provided message history for later verification.
     *
     * @param is The ObjectInputStream connected to the client from which data is received.
     * @param msgHistory A ByteArrayOutputStream to log the received objects, aiding in message integrity verification.
     * @return The client's certificate as received from the stream, allowing further validation.
     */
    public static Certificate receiveCertificateAndKeys(ObjectInputStream is, ByteArrayOutputStream msgHistory) {
        try {
            Certificate clientCertificate = (Certificate) is.readObject();
            msgHistory.write(clientCertificate.toString().getBytes());
            BigInteger clientDHPublicKey = (BigInteger) is.readObject();
            msgHistory.write(clientDHPublicKey.toByteArray());
            byte[] clientSignedDHKey = (byte[]) is.readObject();
            msgHistory.write(clientSignedDHKey);
            System.out.println("Certificate and Keys received");
            return clientCertificate;
        }catch (IOException | ClassNotFoundException e) {
            throw new RuntimeException("Failed to receive certificate and keys: " + e.getMessage(), e);
        }
    }
    /**
     * Validates the received certificate against the known CA certificate and generates master and session keys
     * if the validation is successful.
     *
     * @param nonce A byte array representing a nonce used in session key generation to ensure key uniqueness.
     * @param certificate The certificate received from the other party, to be validated.
     * @param dhPublicKey The Diffie-Hellman public key of the other party.
     * @param dhPrivateKey The Diffie-Hellman private key of the current party.
     * @return A BigInteger representing the master key if validation is successful; null otherwise.
     */
    public static BigInteger validateAndGenerateMasterandSessionKeys(byte[] nonce, Certificate certificate, BigInteger dhPublicKey, BigInteger dhPrivateKey) {
        if(Shared.validateCertificate(certificate)){
            BigInteger masterKey = Shared.generateMasterKey(dhPublicKey, dhPrivateKey);
            Shared.generateSessionKeys(nonce, masterKey.toByteArray());
            return masterKey;
        }
        else{
            return null;
        }
    }
    /**
     * Generates a Message Authentication Code (MAC) for the accumulated message history and sends it to the other party.
     * This method ensures the integrity and authenticity of the previously exchanged messages by creating a MAC and
     * sending it over.
     *
     * @param caller Indicates whether the 'server' or 'client' is calling this method, determining which MAC key to use.
     * @param os The ObjectOutputStream to send the generated MAC message.
     * @param msgHistory The accumulated message history used to generate the MAC.
     */
    public static void generateMacMsg(String caller, ObjectOutputStream os, ByteArrayOutputStream msgHistory) {
        try {
            byte[] key;
            if (caller.equals("server")) {
                key = Shared.serverMAC;
            } else {
                key = Shared.clientMAC;
            }
            byte[] msg = Shared.generateMacMessage(msgHistory.toByteArray(), key);
            os.writeObject(msg);
            System.out.println("Mac msg sent");
        } catch (IOException e) {
            throw new RuntimeException("Failed to generate MAC message: " + e.getMessage(), e);
        }
    }
    /**
     * Receives a Message Authentication Code (MAC) message from the other party.
     * This method is part of the secure communication process, where both parties exchange MACs to verify the integrity
     * and authenticity of the exchanged messages up to this point.
     *
     * @param is The ObjectInputStream from which the MAC message is received.
     * @return A byte array representing the received MAC message.
     */
    public static byte[] receiveMacMsg(ObjectInputStream is) {
        try {
            byte[] clientHMACMessage = (byte[])is.readObject();
            System.out.println("Mac msg received");
            return clientHMACMessage;
        } catch (IOException | ClassNotFoundException e) {
            throw new RuntimeException("Failed to receive MAC message: " + e.getMessage(), e);
        }
    }
    /**
     * Validates the received MAC message against the locally generated MAC of the message history.
     * This validation ensures that the message history has not been tampered with and is authentic.
     *
     * @param caller Indicates whether the 'server' or 'client' is validating the received MAC, determining which MAC key to use.
     * @param msg The received MAC message to be validated.
     * @param msgHistory The accumulated message history against which the received MAC is validated.
     */
    public static void validateMacMsg(String caller, byte[] msg, ByteArrayOutputStream msgHistory) {
        byte[] key;
        if(caller.equals("server")) {
            key = Shared.clientMAC;
        }
        else{
            key = Shared.serverMAC;
        }
        if(Shared.verifyMessageHistory(msg, msgHistory.toByteArray(), key)){
            System.out.println("SERVER HANDSHAKE COMPLETED");
        }
        else {
            System.out.println("HMAC MESSAGES WERE NOT THE SAME");
        }
    }

    //////////////////////////////////////////////////////////////////////
    /////////////////      SHARED MESSAGE METHODS      //////////////////
    ////////////////////////////////////////////////////////////////////

    /**
     * Encrypts and sends a message based on the caller's identity. Uses caller-specific encryption keys and IV.
     *
     * @param caller The entity ('server' or 'client') calling this method, determining encryption specifics.
     * @param os     ObjectOutputStream to write the encrypted message to.
     * @param msg    The plaintext message to encrypt and send.
     */
    public static void sendEncryptedMessage(String caller, ObjectOutputStream os, String msg) {
        try {
            byte[] message_encrypted = caller.equals("server") ?
                    Shared.encryptMessage(msg, Shared.serverMAC, Shared.serverEncrypt, Shared.serverIV) :
                    Shared.encryptMessage(msg, Shared.clientMAC, Shared.clientEncrypt, Shared.clientIV);
            os.writeObject(message_encrypted);
        } catch(IOException e) {
            throw new RuntimeException("Failed to send encrypted message: " + e.getMessage(), e);
        }
    }
    /**
     * Decrypts a received encrypted message based on the caller's identity.
     *
     * @param caller Identifies the caller ('server' or 'client') to use correct decryption keys and IV.
     * @param is     ObjectInputStream from which to read the encrypted message.
     * @return The decrypted plaintext message.
     */
    public static String receiveEncryptedMessage(String caller, ObjectInputStream is) {
        try {
            byte[] receivedMsg_encrypted = (byte[]) is.readObject();
            return caller.equals("server") ?
                    Shared.decryptMessage(receivedMsg_encrypted, Shared.clientEncrypt, Shared.clientIV) :
                    Shared.decryptMessage(receivedMsg_encrypted, Shared.serverEncrypt, Shared.serverIV);
        } catch (IOException | ClassNotFoundException e) {
            throw new RuntimeException("Failed to receive or decrypt the message: " + e.getMessage(), e);
        }
    }

}
